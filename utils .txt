// utils.ts - Utility functions and static classes

import { Vector2D, GameConfig } from ‘./types’;

export const Vector2DUtils = {
create: (x: number = 0, y: number = 0): Vector2D => ({ x, y }),

add: (a: Vector2D, b: Vector2D): Vector2D => ({
x: a.x + b.x,
y: a.y + b.y
}),

subtract: (a: Vector2D, b: Vector2D): Vector2D => ({
x: a.x - b.x,
y: a.y - b.y
}),

multiply: (v: Vector2D, scalar: number): Vector2D => ({
x: v.x * scalar,
y: v.y * scalar
}),

magnitude: (v: Vector2D): number =>
Math.sqrt(v.x * v.x + v.y * v.y),

normalize: (v: Vector2D): Vector2D => {
const mag = Vector2DUtils.magnitude(v);
return mag === 0 ? { x: 0, y: 0 } : { x: v.x / mag, y: v.y / mag };
},

distance: (a: Vector2D, b: Vector2D): number =>
Vector2DUtils.magnitude(Vector2DUtils.subtract(b, a))
};

export const gameConfig: GameConfig = {
canvas: {
width: 1920,
height: 1080,
pixelRatio: 1
},
ui: {
statusBarHeight: 0.15
},
physics: {
gravityStrength: 0.001,
frictionFactor: 0.999,
maxVelocity: 500
},
colors: {
bgPrimary: ‘#1a1a2a’,
hullPrimary: ‘#dcd0c0’,
hullSecondary: ‘#8c8c8c’,
accentFriendly: ‘#5f9e9e’,
accentHostile: ‘#b45f5f’,
accentNeutral: ‘#a09078’,
fxGlowPrimary: ‘#00ffff’,
fxGlowSecondary: ‘#ff8c00’
}
};

export class PhysicsEngine {
static applyNewtonianMotion(
object: { position: Vector2D; velocity: Vector2D },
deltaTime: number,
friction: number = 0.999
): void {
object.position.x += object.velocity.x * deltaTime;
object.position.y += object.velocity.y * deltaTime;

```
const frictionFactor = Math.pow(friction, deltaTime);
object.velocity.x *= frictionFactor;
object.velocity.y *= frictionFactor;
```

}

static applyGravity(
object: { position: Vector2D; velocity: Vector2D },
gravitySources: Array<{ position: Vector2D; mass: number; radius: number }>,
deltaTime: number,
gravityStrength: number = 0.001
): void {
gravitySources.forEach(source => {
const dx = source.position.x - object.position.x;
const dy = source.position.y - object.position.y;
const distance = Math.sqrt(dx * dx + dy * dy);

```
  if (distance > source.radius * 2) {
    const force = (source.mass * gravityStrength) / (distance * distance);
    const angle = Math.atan2(dy, dx);
    
    object.velocity.x += Math.cos(angle) * force * deltaTime;
    object.velocity.y += Math.sin(angle) * force * deltaTime;
  }
});
```

}

static checkCollision(
obj1: { position: Vector2D; radius: number },
obj2: { position: Vector2D; radius: number }
): boolean {
const dx = obj2.position.x - obj1.position.x;
const dy = obj2.position.y - obj1.position.y;
const distance = Math.sqrt(dx * dx + dy * dy);
return distance < (obj1.radius + obj2.radius);
}

static calculateDistance(pos1: Vector2D, pos2: Vector2D): number {
const dx = pos2.x - pos1.x;
const dy = pos2.y - pos1.y;
return Math.sqrt(dx * dx + dy * dy);
}

static normalizeVector(vector: Vector2D): Vector2D {
const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
if (magnitude === 0) return { x: 0, y: 0 };
return { x: vector.x / magnitude, y: vector.y / magnitude };
}
}

export class SeededRandom {
private seed: number;

constructor(seed: number) {
this.seed = seed;
}

next(): number {
this.seed = (this.seed * 9301 + 49297) % 233280;
return this.seed / 233280;
}

nextInt(min: number, max: number): number {
return Math.floor(this.next() * (max - min + 1)) + min;
}

nextFloat(min: number, max: number): number {
return this.next() * (max - min) + min;
}

choose<T>(array: T[]): T {
return array[Math.floor(this.next() * array.length)];
}
}

export class MathUtils {
static clamp(value: number, min: number, max: number): number {
return Math.max(min, Math.min(max, value));
}

static lerp(a: number, b: number, t: number): number {
return a + (b - a) * t;
}

static smoothstep(edge0: number, edge1: number, x: number): number {
const t = MathUtils.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
return t * t * (3.0 - 2.0 * t);
}

static radToDeg(radians: number): number {
return radians * (180 / Math.PI);
}

static degToRad(degrees: number): number {
return degrees * (Math.PI / 180);
}

static angleToVector(angle: number): Vector2D {
return {
x: Math.cos(angle),
y: Math.sin(angle)
};
}

static vectorToAngle(vector: Vector2D): number {
return Math.atan2(vector.y, vector.x);
}

static wrap(value: number, min: number, max: number): number {
const range = max - min;
if (range <= 0) return min;

```
let result = value;
while (result < min) result += range;
while (result >= max) result -= range;
return result;
```

}
}

export class TimeUtils {
private static startTime: number = Date.now();

static getTime(): number {
return Date.now();
}

static getGameTime(): number {
return (Date.now() - TimeUtils.startTime) / 1000;
}

static formatTime(seconds: number): string {
const hours = Math.floor(seconds / 3600);
const minutes = Math.floor((seconds % 3600) / 60);
const secs = Math.floor(seconds % 60);

```
if (hours > 0) {
  return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}
return `${minutes}:${secs.toString().padStart(2, '0')}`;
```

}

static sleep(ms: number): Promise<void> {
return new Promise(resolve => setTimeout(resolve, ms));
}
}

export class ColorUtils {
static hexToRgb(hex: string): { r: number; g: number; b: number } | null {
const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
return result ? {
r: parseInt(result[1], 16),
g: parseInt(result[2], 16),
b: parseInt(result[3], 16)
} : null;
}

static rgbToHex(r: number, g: number, b: number): string {
return “#” + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

static interpolateColor(color1: string, color2: string, factor: number): string {
const rgb1 = ColorUtils.hexToRgb(color1);
const rgb2 = ColorUtils.hexToRgb(color2);

```
if (!rgb1 || !rgb2) return color1;

const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor);
const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor);
const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor);

return ColorUtils.rgbToHex(r, g, b);
```

}

static addAlpha(color: string, alpha: number): string {
const rgb = ColorUtils.hexToRgb(color);
if (!rgb) return color;

```
return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
```

}
}